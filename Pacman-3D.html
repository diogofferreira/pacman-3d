<!DOCTYPE html>

<html>

<head>
	
<title>Pacman 3D by Apollo</title>

<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script id="shader-vs" type="x-shader/x-vertex">
	
    attribute vec3 aVertexPosition;

    attribute vec2 aTextureCoord;
    
    uniform mat4 uMVMatrix;

    uniform mat4 uPMatrix;

    varying vec2 vTextureCoord;
    
    varying vec4 fColor;
    
    // For the Phong Illumination Model
    
    attribute vec3 vNormal;
    
    uniform vec4 viewerPosition;
	
    // NEW - Array of lights
    
	#define MAX_LIGHTS 5

	uniform int numLights;

	uniform struct Light {
	
		vec4 position;
   
		mat4 lightSourceMatrix;

		vec3 intensities;
   
		vec3 ambientIntensities;
			
	} allLights[MAX_LIGHTS];
    
    // The material properties

	uniform vec3 k_ambient;
	
	uniform vec3 k_diffuse;
	
	uniform vec3 k_specular;
	
    uniform float shininess;
    
    void main(void) {
		
		// To allow seeing the points drawn
		
		gl_PointSize = 5.0;
		
		// Just converting the (x,y,z) vertices to Homogeneous Coord.
		
		// And multiplying by the Projection and the Model-View matrix
		
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);

        // Phong Illumination Model
        
        // Pos is vertex position after applying the global transformation
    
        vec3 pos = (uMVMatrix * vec4(aVertexPosition, 1.0)).xyz;
    
		fColor = vec4(0.0, 0.0, 0.0, 0.0);	
		 		
		for( int i = 0; i < MAX_LIGHTS; i++ ) 
		{
			if( i == numLights )
			
				break;
				
			// Ambient component is constant for each light source
        
			vec4 ambient = vec4( k_ambient * allLights[i].ambientIntensities, 1.0 );
	   
			fColor += ambient;
		
           // Vector from vertex position to light source
    
           vec3 L;
        
           // Check for directional light
    
           if(allLights[i].position.w == 0.0) 
        
				L = normalize( (allLights[i].lightSourceMatrix * allLights[i].position).xyz );
        
           else 
        
			    L = normalize( (allLights[i].lightSourceMatrix * allLights[i].position).xyz - pos );
			
		   // Vector from the vertex position to the eye
		
		   vec3 E;
		
		   // The viewer is at the origin or at an indefinite distance
		   // On the ZZ axis
		
		   if(viewerPosition.w == 1.0) 
        
			   // At the origin
			
			   E = -normalize( pos );
        
           else 
        
			   // On the ZZ axis
			
			   E = vec3(0,0,1);
		    
           // Halfway vector
    
           vec3 H = normalize( L + E );

           // Transform vertex normal into eye coordinates
    
           vec4 N = normalize( uMVMatrix * vec4(vNormal, 0.0));

           // Compute terms in the illumination equation
        
		   // Diffuse component 
		
		   float dotProductLN = L[0] * N[0] + L[1] * N[1] + L[2] * N[2]; 
		
           float cosNL = max( dotProductLN, 0.0 );
    
           vec4  diffuse = vec4( k_diffuse * cosNL * allLights[i].intensities, 1.0 );
        
           // Specular component

           float dotProductNH = N[0] * H[0] + N[1] * H[1] + N[2] * H[2]; 
		
		   float cosNH = pow( max( dotProductNH, 0.0 ), shininess );
    
           vec4  specular = vec4( k_specular * cosNH * allLights[i].intensities, 1.0 );
    
           if( dotProductLN < 0.0 ) {
	
		      specular = vec4(0.0, 0.0, 0.0, 1.0);
           } 

		   // Adding the components
		
           fColor += diffuse + specular;
	   }
        
        // Converting the RGB color value to RGBA
        
        vTextureCoord = aTextureCoord;

    }
</script>

<script id="shader-fs" type="x-shader/x-fragment">

	precision mediump float;
	
	varying vec2 vTextureCoord;

	varying vec4 fColor;

    uniform sampler2D uSampler;

	void main(void) {
		
		// Using the passed vertex color (color * texture)
		
        gl_FragColor = fColor * texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
	}

</script>

<!-- The JS files -->

<!-- Some useful functions for browser compatibility -->

<script type="text/javascript" src="webgl-utils.js"></script>

<!-- Handling vectors and matrices -->

<script type="text/javascript" src="maths.js"></script>

<!-- Processing triangle mesh models -->

<script type="text/javascript" src="models.js"></script>

<!-- Creating the light sources -->

<script type="text/javascript" src="lightSources.js"></script>

<!-- WebGL code -->

<script type="text/javascript" src="initShaders.js"></script>

<script type="text/javascript" src="Pacman-3D.js"></script>

</head>

<body onload="runWebGL();" style="background: black;">
	<div align="center">
		<img src="assets/logo.gif" style="width:300px; height:150px;"/>
	</div>

	<div align="center" id="welcome-screen" style="display:block;color:white; width:900px; height:650px; border-style: solid; border-width:5px; border-radius: 25px; margin:0 auto;">
		<br/>
		<br/>
		<br/>
		<span style="font-size:25px;">
			<u>INSTRUCTIONS</u>: 
			<br/>
			<br/>1. USE THE ARROWS TO MOVE THE PACMAN
			<br/>
			<br/>2. USE MOUSE DRAG TO CHANGE CAMERA POSITION
			<br/>
			<br/>3. USE MOUSE WHEEL TO ZOOM IN OR OUT
			<br/>
			<br/>4. IF YOU WANT TO USER A CUSTOM FIELD, UPLOAD A FILE BELOW WITH A
			<br/> MATRIX M x N WITH f FOR FOOD, s FOR SUPER-FOOD, w FOR WALL AND p FOR PORTALS, SEPARATED BY COMMAS.
		</span>
		<br/>
		<br/>
		<br/>
		<input type="file" id="file" name="file">
		<br/>
		<br/>
		<span style="font-size:35px;color:yellow;">PRESS SPACE TO START!</span>
	</div>

	<div id="game" align="center" style="display:none;">
		<canvas id="my-canvas" style="border: none;" width="800" height="600"></canvas>		

		<h3 id="score" style="color:yellow;"></h3>
		<h1 id="super-mode" style="color:red;"></h1>
		<h1 id="result" style="color:yellow;"></h2>
	</div>
</body>

</html>